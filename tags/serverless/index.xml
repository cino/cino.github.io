<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>serverless on Cino</title><link>https://cino.io/tags/serverless/</link><description>Cino (serverless)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 11 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://cino.io/tags/serverless/index.xml" rel="self" type="application/rss+xml"/><item><title>Limiting AWS Lambda's access to Log Groups</title><link>https://cino.io/posts/limiting-aws-lambdas-access-to-log-groups/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://cino.io/posts/limiting-aws-lambdas-access-to-log-groups/</guid><description>&lt;p>About a year ago I asked the question on &lt;a href="https://www.reddit.com/r/aws/comments/o3fbge/is_awslambdabasicexecutionrole_not_way_too_open/">Reddit&lt;/a> what people thought of the default Lambda role called &amp;ldquo;AWSLambdaBasicExecutionRole&amp;rdquo; and why I thought it was way too open to be a default.&lt;/p>
&lt;p>To this day I still think this role shouldn&amp;rsquo;t be used at all, but rather be deleted by Amazon itself. While I agree that Amazon wants people to get started as quickly as possible it is not in line with the least access principle. For this reason, I always define the role myself, for starters only allowing the Lambda function to write to its own CloudWatch Log Group. There is no reason for the Lambda function to be able to write to log groups of other services rather than its own.&lt;/p>
&lt;p>Luckily it&amp;rsquo;s quite simple to create a custom permission for the Lambda function using the CDK. We can simply create a custom role, assign the role without permissions to the Lambda function, then add the custom permission to the role allowing the correct permissions to write to the CloudWatchlog group. Why in this order? We need this order to retrieve the generated LogGroup location from the Lambda in the permission, if we wouldn&amp;rsquo;t be using the AWS CDK we would&amp;rsquo;ve done this directly in the permission by assuming the correct name. Luckily this isn&amp;rsquo;t necessary and this is future proof (and re-usable when you put it in a custom struct/generate it in a function).&lt;/p>
&lt;p>As an example, I&amp;rsquo;ve created the smallest working CDK project which displays exactly how this can be realized below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Create your custom IAM Role
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">customRole&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Role&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;CustomRole&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">roleName&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;CustomRole&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assumedBy&lt;/span>: &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">ServicePrincipal&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;lambda.amazonaws.com&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// create smallest lambda function possible and assign the custom role.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">lambdaFunction&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">NodejsFunction&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Function&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">entry&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;./dist/function.js&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">role&lt;/span>: &lt;span style="color:#66d9ef">customRole&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Create an inline policy which only allows the role to write logs to the log group
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// that is automatically created by the lambda function.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">customRole&lt;/span>.&lt;span style="color:#a6e22e">attachInlinePolicy&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Policy&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;loggingPolicy&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">statements&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">PolicyStatement&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">effect&lt;/span>: &lt;span style="color:#66d9ef">Effect.ALLOW&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">actions&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;logs:CreateLogGroup&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resources&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;*&amp;#39;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">PolicyStatement&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">effect&lt;/span>: &lt;span style="color:#66d9ef">Effect.ALLOW&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">actions&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;logs:CreateLogStream&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;logs:PutLogEvents&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resources&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">lambdaFunction&lt;/span>.&lt;span style="color:#a6e22e">logGroup&lt;/span>.&lt;span style="color:#a6e22e">logGroupArn&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>A full working example can be found in my Github repository containing this and future examples at &lt;a href="https://github.com/cino/cdk-examples/tree/main/lambda-custom-role">this location&lt;/a>.&lt;/p></description></item><item><title>Building a Serverless Kanban Board</title><link>https://cino.io/posts/building-a-serverless-kanban-board/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>https://cino.io/posts/building-a-serverless-kanban-board/</guid><description>&lt;p>&lt;strong>Update 18/01/2023: Let&amp;rsquo;s assume this is not gonna happen anymore&lt;/strong>&lt;/p>
&lt;p>As the title suggests I&amp;rsquo;m planning on building a Serverless Kanban Board to improve my personal Typescript skills in both the front and back end. Furthermore, the whole project will be set up while using Amazon Web Services (of course ðŸ˜‰)&lt;/p>
&lt;p>I thought it would be fun to build something for practice and also have some personal projects on my GitHub page that display the latest techniques I&amp;rsquo;m working with and as a bonus get some material I can write about on the website!&lt;/p>
&lt;h2 id="the-plan" >The plan
&lt;span>
&lt;a href="#the-plan">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>So how is this going the be built? For building the application I&amp;rsquo;ve set a couple of rules for myself:&lt;/p>
&lt;ol>
&lt;li>Everything needs to be Serverless, with zero servers, and zero operating systems we need to manage.&lt;/li>
&lt;li>Everything needs to be built with Infrastructure as Code&lt;/li>
&lt;li>s cheap as possible&lt;/li>
&lt;li>Stateless (Api driven)&lt;/li>
&lt;li>Automatically tested&lt;/li>
&lt;/ol>
&lt;p>To explain every rule a bit more let&amp;rsquo;s break it down. First of all, as the title already suggested everything needs to be serverless. That is the most important part of this exercise for me as this is a requirement at my current employer (all are, to be honest) and I really like to have more hands-on experience going forward.&lt;/p>
&lt;p>Secondly, this is something that has been around for more than a few years; You really want to have reproducible deployments and can be sure that every deployment will result in the same result. This will be done by using the AWS CDK and all deployments to the AWS Account will be automated with a Github Action while using the OIDC Connection.&lt;/p>
&lt;p>Thirdly, this is quite simple. I am deploying this to my personal AWS account and I really like to keep it as cheap as possible to reduce any costs at my end. I will be publishing a report later to display how much this has cost me in the last periods over probably a time span of months. As serverless is mostly billed on usage level and usage will be very low I&amp;rsquo;m planning on staying in the Free tier as much as possible.&lt;/p>
&lt;p>Stateless, this is an absolute necessity when building scalable applications. As we are building a serverless application it also means we have no infrastructure where we can temporarily store our data on a disk/memory as this will all be destroyed after the request. So this means that anytime we like to keep data, we will need to use a Serverless service like Amazon S3 for example.&lt;/p>
&lt;p>And last but not least we are going to automatically test everything we set up, from the infrastructure with CDK to the code we write for AWS Lambdas in Typescript. This is a hard requirement for any project in the developer world in my personal opinion. Some tests may not be there in the beginning but we will definitely keep track of everything that has to be tested or even try some TDD (Test Driven Development) in there as well.&lt;/p>
&lt;h2 id="the-design" >The design
&lt;span>
&lt;a href="#the-design">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>As every good project starts it starts with a high-level overview of how we are planning to set up the infrastructure, and of course, this has been done with &lt;a href="https://draw.io">draw.io&lt;/a>&lt;/p>
&lt;p>This is most definitely the first sketch and I will keep modifying this if I find myself making a mistake in the future, which is almost a guarantee.&lt;/p>
&lt;img src="https://cino.io/img/building-a-serverless-kanban-board/Serverless-Kanban.drawio-1.png">
&lt;p>This is the basic setup of how we are going to set this up, and this should be quite easy to understand.&lt;/p>
&lt;p>We are going to create 2 different subdomains where the application is going to live, the front-end application at kanban.cino.io and the back-end API at kanban-api.cino.io where we will require Cognito Authorization before allowing the user to execute any API requests. Behind the API Gateway, we have multiple AWS Lambda functions (1 for every endpoint we need to keep the function as small as possible) which can all communicate with our database Amazon DynamoDB and every function is able to send an email by Amazon SES. As an extra Serverless feature, I&amp;rsquo;d like to play around with DynamoDB streams to automate certain actions as I&amp;rsquo;ve never used this service before. For example, we can automatically send an email to users that are following a certain kanban ticket when the status has changed because DynamoDB can trigger an event when data changes on the record.&lt;/p>
&lt;p>The front-end is a lot smaller at the moment, that will host the application in an S3 Bucket and keep the static assets in another S3 Bucket, both of these will be served to the internet by the same CloudFront instance as we can use multiple origins and specify the path, this will mean that we cannot use the path &amp;ldquo;assets&amp;rdquo; in our application itself.&lt;/p>
&lt;h2 id="going-forward" >Going forward
&lt;span>
&lt;a href="#going-forward">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>From now on I will be working on this side-project quite often and keep writing blogs about it. As the first few steps I&amp;rsquo;m going to set up a decent Github Project to keep up with all the tasks I&amp;rsquo;m going to work on, setting up the actual Live environment, might add a test environment but as this is a fun side-project I guess that ain&amp;rsquo;t gonna happen :).&lt;/p>
&lt;p>Besides setting up all these necessities the first actual problem that I&amp;rsquo;ll need to face which is new for me is: Adding Cognito authentication to a React app in a secure way!&lt;/p></description></item><item><title>Static website distribution with AWS CloudFront</title><link>https://cino.io/posts/static-website-distribution-with-aws-cloudfront/</link><pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate><guid>https://cino.io/posts/static-website-distribution-with-aws-cloudfront/</guid><description>&lt;p>Having only written about PHP and Servers in the past I am making the switch to Serverless. This has been a long-time wish for me and finally realized this in a personal but also professional environment. That being said, I plan on writing a lot of new content on the blog purely around setting up applications with a serverless mindset, built with AWS CDK (AWS Cloud Development Kit). I will include diagrams and/or flowcharts to explain what is happening and of course, include the source code in a public GitHub repository.&lt;/p>
&lt;p>The bigger goal for me is to develop a proper application on nothing but serverless services from Amazon to train my skillset and also share the process that I went through.&lt;/p>
&lt;h2 id="before-we-get-started" >Before we get started
&lt;span>
&lt;a href="#before-we-get-started">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>First things first, the way I&amp;rsquo;m making my content won&amp;rsquo;t be a step-by-step guide. At this point, I assume you are at least familiar with Amazon Web Services, Infrastructure as Code and read up at least a little about the &lt;a href="https://docs.aws.amazon.com/cdk/v2/guide/home.html">Cloud Development Kit&lt;/a>.&lt;/p>
&lt;p>At this moment you should already have the following tools installed:&lt;/p>
&lt;ul>
&lt;li>Node/NPM&lt;/li>
&lt;li>Typescript&lt;/li>
&lt;li>AWS CDK&lt;/li>
&lt;/ul>
&lt;h2 id="what-are-we-building" >What are we building?
&lt;span>
&lt;a href="#what-are-we-building">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>The easiest project to experiment with serverless on AWS is with a basic static website. Let&amp;rsquo;s say you only have some HTML/JS/CSS files, we can easily host the website with Amazon S3 + Amazon CloudFront. That means we have a storage provider where we can store our files and a service that helps us serve the files to the visitors. As a bonus, CloudFront serves as a Content Delivery Network which means the files are cached over multiple regions in the world if necessary.&lt;/p>
&lt;p>For this particular example, I&amp;rsquo;ve chosen &lt;strong>not&lt;/strong> to use a custom domain for the CloudFront distribution. Because at the moment, I don&amp;rsquo;t have a hosted zone setup within AWS and it doesn&amp;rsquo;t really add value at this point.&lt;/p>
&lt;p>How this would work from a user perspective is quite simple, whenever the user requests an object it would first check if it exists in the cache. When it does, it is as returning the cached file. When it is not in the cache, that&amp;rsquo;s when CloudFront checks if it exists in the origin (S3 in our case) and acts depending on if it is found or not.&lt;/p>
&lt;img src="https://cino.io/img/static-website-distribution-with-aws-cloudfront/flowchart-static-website-distribution-with-aws-cloudfront.drawio.png">
&lt;h2 id="infrastructure-as-code" >Infrastructure as Code
&lt;span>
&lt;a href="#infrastructure-as-code">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>As a best practice, you should use infrastructure as code as much as possible. As said earlier my preferred tool at the moment would be the AWS CDK and this is what I&amp;rsquo;ll show today on how I&amp;rsquo;ve set this up. I&amp;rsquo;ll be going over the main stack I&amp;rsquo;ve created in CDK which can be found &lt;a href="https://github.com/cino/cdk-static-serverless/blob/initial-static-website/lib/cdk-static-serverless-stack.ts">here&lt;/a> for those who like to read along.&lt;/p>
&lt;p>To start we need to create an S3 Bucket where all our files will be stored. In the example, we will just be storing an index.html and a favicon.ico. As you can see below, we kept it really simple.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">bucket&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">s3&lt;/span>.&lt;span style="color:#a6e22e">Bucket&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;StaticWebsiteBucket&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">bucketName&lt;/span>: &lt;span style="color:#66d9ef">Stack.of&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>).&lt;span style="color:#a6e22e">account&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-static-website-test&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">websiteIndexDocument&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;index.html&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">publicReadAccess&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">blockPublicAccess&lt;/span>: &lt;span style="color:#66d9ef">s3.BlockPublicAccess.BLOCK_ALL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>The only notable comment here is that we disable public access to the bucket which is an actual best practice. Every time you create a bucket: make it private. If you do need it to be public, really ask yourself if it&amp;rsquo;s necessary. In our current situation, all our files are publicly accessible but only when visiting from our CloudFront distribution.&lt;/p>
&lt;p>After we&amp;rsquo;ve created our S3 Bucket we are going to allow access with an Origin Access Identity where we are basically going to allow CloudFront to access all our files in the S3 Bucket but only on the &lt;code>s3:GetObject&lt;/code> action. Just retrieving the files and nothing else.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">cloudfrontOAI&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">cloudfront&lt;/span>.&lt;span style="color:#a6e22e">OriginAccessIdentity&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;cloudfront-OAI&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">comment&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`OAI for &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">bucket&lt;/span>.&lt;span style="color:#a6e22e">addToResourcePolicy&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">iam&lt;/span>.&lt;span style="color:#a6e22e">PolicyStatement&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">actions&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;s3:GetObject&amp;#39;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">resources&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#a6e22e">bucket&lt;/span>.&lt;span style="color:#a6e22e">arnForObjects&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;*&amp;#39;&lt;/span>)],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">principals&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">iam&lt;/span>.&lt;span style="color:#a6e22e">CanonicalUserPrincipal&lt;/span>(&lt;span style="color:#a6e22e">cloudfrontOAI&lt;/span>.&lt;span style="color:#a6e22e">cloudFrontOriginAccessIdentityS3CanonicalUserId&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}));&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Now the bucket is completely ready we can create the CloudFront distribution where we will use this bucket as an origin source and configure the origin access identity to ensure everybody is up to date on what is allowed.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">distribution&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">cloudfront&lt;/span>.&lt;span style="color:#a6e22e">CloudFrontWebDistribution&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;StaticWebsiteDistribution&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">originConfigs&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">s3OriginSource&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">s3BucketSource&lt;/span>: &lt;span style="color:#66d9ef">bucket&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">originAccessIdentity&lt;/span>: &lt;span style="color:#66d9ef">cloudfrontOAI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">behaviors&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">isDefaultBehavior&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">compress&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">allowedMethods&lt;/span>: &lt;span style="color:#66d9ef">cloudfront.CloudFrontAllowedMethods.GET_HEAD_OPTIONS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>While all the services are now in place within AWS there is only one part missing, how do we get our files in the s3 bucket? This is something that I thought was annoying to deal with but I was completely wrong! In the AWS CDK, there is this beautiful library called &lt;code>aws-s3-deployment&lt;/code> which can automate the deployment from the CDK template.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">s3deploy&lt;/span>.&lt;span style="color:#a6e22e">BucketDeployment&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;DeployWithInvalidation&amp;#39;&lt;/span>, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sources&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#a6e22e">s3deploy&lt;/span>.&lt;span style="color:#a6e22e">Source&lt;/span>.&lt;span style="color:#a6e22e">asset&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;./static&amp;#39;&lt;/span>)],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">destinationBucket&lt;/span>: &lt;span style="color:#66d9ef">bucket&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">distribution&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">distributionPaths&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;/*&amp;#39;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Here you&amp;rsquo;ll see all the pieces coming together. We are deploying our files from the static folder to our specified bucket and because we are mentioning our CloudFront distribution the deployment will automatically take care of invalidating the caching of these files.&lt;/p>
&lt;h2 id="interesting-learnings" >Interesting learnings
&lt;span>
&lt;a href="#interesting-learnings">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>A couple of things that I found really interesting is that while using Amazon CloudFront the most important statistic is of course your cache hit/miss ratio. When the percentage of misses is too high there is probably something wrong with your setup. However, in my initial deployment, I had a lot of errors in the CloudFront console. The reason behind it was that I was missing a favicon.ico in the static website. This was a logical result of requesting the website from the browser, on every request the browser would try to retrieve the favicon to display in the tab bar. Just for that statistic alone, my advice would be, just add a favicon to the website and never think about it again.&lt;/p>
&lt;h2 id="closing-note" >Closing note
&lt;span>
&lt;a href="#closing-note">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>This is the easiest way to get started with a serverless website. It&amp;rsquo;s fairly simple to set up but covers the basics of what you need to know and how to progress in the world of serverless. However, this is by far not the production-ready state you want to run your application. For starters, you should use your own domain instead of the *.cloudfront.net endpoint and that would give you some extra work with configuring Route53 + SSL Certificate (in combination with CloudFront of course).&lt;/p>
&lt;p>Besides that, at the current source code, it is necessary to deploy every change yourself. This is not something you want, it would be much nicer to have this in an automated pipeline in for example AWS CodePipeline or my preferred way of deploying which is with GitHub Actions.&lt;/p>
&lt;p>In the next post, I&amp;rsquo;ll be talking about how to set up your GitHub repository to deploy on every update!&lt;/p>
&lt;p>Github: &lt;a href="https://github.com/cino/cdk-static-serverless/tree/initial-static-website">https://github.com/cino/cdk-static-serverless/tree/initial-static-website&lt;/a>&lt;/p></description></item></channel></rss>